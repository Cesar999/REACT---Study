What is React?
    React is a front-end JavaScript library developed by facebook.
    It follows the component based approach which helps in building rusable UI elements. React uses the Virtual DOM and unidirectional data binding.

create-react-app?
    is the official CLI (Command Line Interface) for React to create React apps with no build configuration.
    We don’t need to install or configure tools like Webpack or Babel. They are preconfigured and hidden so that we can focus on the code. We can install easily just like any other node modules. Then it is just one command to start the React project.

    npm start Runs the app in development mode. Open http://localhost:3000 to view it in the browser.

    npm test Runs the test watcher in an interactive mode. By default, runs tests related to files changed since the last commit.

    npm run build
    Builds the app for production to the build folder. It correctly bundles React in production mode and optimizes the build for the best performance.

What is the Virtual DOM?
    The Virtual DOM is an abstraction of the HTML DOM. It is lightweight and detached from the browser-specific implementation details. ReactElements lives in the virtual DOM. They make the basic nodes here. Once we defined the elements, ReactElements can be render into the "real" DOM. This Virtual DOM works in three simple steps.
    Whenever any underlying data changes, the entire UI is re-rendered in Virtual DOM representation.
    Then the difference between the previous DOM representation and the new one is calculated.
    Once the calculations are done, the real DOM will be updated with only the things that have actually changed. 

What is JSX?
    JSX is a syntax extension to JavaScript that React utilizes JavaScript along with HTML like template syntax JSX to produce React "elements".
    You can embed any JavaScript expression in JSX by wrapping it in curly braces. This means that you can use JSX inside of if statements and for loops, assign it to variables, accept it as arguments, and return it from functions. Eventhough React does not require JSX, it is the recommended way of describing our UI in React app.

    Browsers can only read JavaScript objects but JSX in not a regular JavaScript object. Thus to enable a browser to read JSX, first, we need to transform JSX file into a JavaScript object using JSX transformers like Babel and then pass it to the browser.

render function?
    This method returns a single React element which is the representation of the native DOM component.  If more than one HTML element needs to be rendered, then they must be grouped together inside one enclosing tag such as <form>, <group>,<div> etc.

react fragments?
    A common pattern in React is for a component to return multiple elements. Fragments let you group a list of children without adding extra nodes to the DOM. <React.Fragment></React.Fragment> or the short syntaxis <></>.

createElement / cloneElement?
    createElement is what JSX gets compiled to and is what React uses to create React Elements (object representations of some UI). cloneElement is used to clone an element and pass it new props.

    React.createElement(type,[props],[...children]) Create and return a new React element of the given type. The type argument can be either a tag name string (such as 'div' or 'span'), a React component type (a class or a function), or a React fragment type.
    It is used to create react elements  without JSX.

    // create React element <li>'s
    var rElmLi1 = React.createElement('li', {id:'li1'}, 'one');
    var rElmLi2 = React.createElement('li', {id:'li2'}, 'two');
    var rElmLi3 = React.createElement('li', {id:'li3'}, 'three');

    //create <ul> React element and add child React <li> elements to it
    var reactElementUl = React.createElement('ul', {className:'myList'}, rElmLi1,rElmLi2,rElmLi3);

    React.cloneElement clone and return a new React element using the passed element as the starting point. The resulting element will have the original element's props with the new props merged in shallowly. New children will replace existing children. key and ref from the original element will be preserved.
    React.cloneElement only works if our child is a single React element. For almost everything {this.props.children} is the better solution. Cloning is useful in some more advanced scenarios, where a parent send in an element and the child component needs to change some props on that element or add things like ref for accessing the actual DOM element.
    React.cloneElement(element, [props], [...children])
    <element.type {...element.props} {...props}>{children}</element.type>

    ./react-dom

React.StrictMode?
    React.StrictMode is a tool to highlight potential problems in the application. Like Fragment, it StrictModedoesn't render anything in the UI. This mode also triggers additional checks and warnings for your descendants.

props?
    Props are properties in React. They are read-only data which must be kept immutable. They are passed down from a parent component to a child component. Never from child to parent. This is to mainatin the unidirectional data flow.

Render props / this.props.children ?
    The term "render prop" refers to a technique for sharing code between components in React using a property whose value is a function. A render prop is a prop that receives a function that a component uses to know what to render.

    Render props pattern consists in when you pass a render function to a component that, in turn, returns a React element. This render function is defined by another component, and the receiving component shares what is passed through the render function.
    The concept of children as a function or child as a function, also called render prop in general, is one of the advanced patterns in React (next to higher-order components). The components which implement this pattern could be called render prop components. 
    The render prop pattern enhances React’s patterns for compositions. Instead of passing the custom components as components, you pass them as a function which renders them.
    Render Prop Component: The render prop pattern enhances React’s patterns for compositions. Instead of passing the currency components as components, you pass them as a function which renders them.
    It gives you a way to pass data from the wrapping component (Amount) to its inner composed component(s) (currency components). Because of this function, you can use the children prop within the render prop component (that’s what the Amount component became by implementing this pattern). The children prop becomes a children as a function.
    It's important to remember that just because the pattern is called render props you don't have to use a called prop renderto use this pattern . In fact, any prop that is a function that a component uses to figure out what to render is technically a "render prop".

    this.props.children it is used to display whatever you include between the opening and closing tags when invoking a component.

   ./example-props

state?
    State is a javascript object owned by the component where it is declared that determines the its rendering and behaviour. Its purpose is to be dynamic an interactive. A component can initialize its state and update it whenever necessary. Thus the state is mutable but it should not be directly mutated.

    setState function enqueues changes to the component state an re-render with the updated state. This is the primary method you use to update the user interface in response to event handlers and server responses.

    The first parameter is an updater function, 
    its parameters are state, props and it returns a javascript object that describes the updated state.

    this.setState((state, props) => {
        return {counter: state.counter + props.step};
    });

    The second parameter is an optional callback function that will be executed once setState is completed and the component is re-rendered.

    setState(updater, callback);

    setState actions are asynchronous and are batched for performance gains.. This is because setState alters the state and causes rerendering. This can be an expensive operation and making it synchronous might leave the browser unresponsive. Thus the setState calls are asynchronous as well as batched for better UI experience and performance.

    ./example-state-lifecycles

Life Cycle methods?
    Every React Component has a lifecycle of its own, lifecycle of a component can be defined as the series of methods that are invoked in different stages of the component’s existence. 
     
    Initialization: This is the stage where the component is constructed with the given Props and default state. This is done in the constructor of a Component Class.
    Mounting: Mounting is the stage of rendering the JSX returned by the render method itself.
    Updating: Updating is the stage when the state of a component is updated and the application is re-rendered.
    Unmounting: As the name suggests Unmounting is the final step of the component lifecycle where the component is removed from the page.

    (INITIAL STAGE)
    constructor() -> getDerivedStateFromProps(props, state) -> render() -> componentDidMount()

    (UPDATING STAGE)
    getDerivedStateFromProps(props, state) -> shouldComponentUpdate(nextProps, nextState) -> render() -> getSnapshotBeforeUpdate(prevProps, prevState) -> componentDidUpdate(prevProps, prevState, snapshot)

    (UNMOUNTING STAGE)
    componentWillUnmount

    (ERROR)
    componentDidCatch

    You can and should use this.setState() in only these React lifecycle methods: componentDidMount and componentDidUpdate. it’s recommend to use the constructor instead. You can also set it in componentDidCatch.

    constructor: This method is called when your component is being created and before mounting (being added to the DOM). Its primary use is to initialize state and .bind(this) for the component’s methods. If you do neither of these, then there is no need for a constructor.

    getDerivedStateFromProps:  It is static. It is called after a component is created and also called when it receives a new prop.
    It returns an object to update state in response to prop changes. It would return null to indicate no change to state.
    React may call this method even if the props have not changed.
    This is the first method that is called when a component gets updated.
    This is still the natural place to set the state object based on the initial props.
    getDerivedStateFromProps(props, state)

    componentDidMount: Your component has now been rendered and exists in the DOM. This is the point when you should initiate AJAX requests, add event listeners, and perform any set up that requires a DOM.

    (state change)
    shouldComponentUpdate: This method exists purely for performance improvements. Renders and reconciliations are expensive in React. shouldComponentUpdate(nextProps, nextState) provides the developer the ability to return a boolean true/false from this method which controls whether React should perform the reconciliation operations and DOM updates.

    getSnapshotBeforeUpdate: This is going to handle what componentWillUpdate was able to do along with componentDidUpdate. This is called right before the DOM is updated. The value that is returned from getSnapshotBeforeUpdate is passed on to componentDidUpdate.
    componentDidUpdate is called as soon as the DOM is updated. The snapshot value is passed on to componentDidUpdate.
    Resizing the window during an async rendering is a good use-case of when the getSnapshotBeforeUpdate can be utilized.
    getSnapshotBeforeUpdate(prevProps, prevState)

    (render)
    componentDidUpdate: Immediately after React builds you a shiny new UI, componentDidUpdate(prevProps, prevState, snapshot) is invoked. This is a great time to interact with the DOM or instantiate a new network request based on what the new interface should look like.

    (unmount)
    componentWillUnmount: Your component had a great life and now it’s time for it to leave the UI. This is the moment to clean up everything that was associated with adding and maintaining your component while it was living on the UI.

    componentDidCatch: componentDidCatch(error, info) is a new lifecycle that was added in React 16. React was notorious for crashing an entire application if a JavaScript error was thrown inside the React app. It corrupted React’s internal state which blew up the app and yielded cryptic error messages. 
    Catch errors in any components below and re-render with error message

    ***DEPRECATED
    The lifecycle methods below are deprecated:
        componentWillMount
        componentWillRecieveProps
        componentWillUpdate

    compomentWillMount: This method is executed right before a component is added to the DOM / render(). It is generally recommended that you use the constructor, but this method is still included in the API mostly for backwards compatibility.

    (props changed)
    componentWillReceiveProps: When your component receives new props from its parent, componentWillReceiveProps(nextProps) is triggered. This is a great time to check if there are changes in the incoming props when compared to your current props and trigger a state change based on the new values.

    (state change)
    componentWillUpdate: React invokes this method immediately before rendering when new props or state are being received. There is not much use for componentWillUpdate(nextProps, nextState) and should probably be avoided (similar to componentWillMount). You should not do anything that would change the state at this point — use componentWillReceiveProps if you need to do anything before a render.

    ./example-state-lifecycles

What is a Component vs Element?
    React element is an object representation of some UI it describes what you want to see on the screen.
    A React component is a function or a class which optionally accepts input and returns a React element (typically via JSX which gets compiled to a createElement invocation). They are the building blocks of a React application’s UI. These components split up the entire UI into small independent and reusable pieces.

Class vs Functional / Stateful vs Stateless?
    Functional components are just JavaScript functions. They take in an optional input which are the props. The can't use the state and the lifecycle unleess you use React hooks.

    Class components are based on ES6 javascript classes and they are able to use the State and the lifecycle methods.

    Stateless/Presentational could be those components that dont use a state, they could be class or functional. Presentational components are reusable and should stay decoupled from the behavioral layer. A presentational component receives the data and callbacks exclusively via props. The presentational component doesn't interact with the Redux store or make API calls. 

    Stateful/Container component are those that use a state they can only be the class components, unless functional using hooks. A container component tells the presentational component what should be rendered using props. If you're using Redux, a container component contains the code that dispatches an action to a store. Alternatively, this is the place where you should place your API calls and store the result into the component's state. 

Pure Component?
    A React component can be considered pure if it renders the same output for the same state and props. For class components like this, React provides the PureComponent base class. Class components that extend the React.PureComponent class are treated as pure components.
    Pure components have some performance improvements and render optimizations since React implements the shouldComponentUpdate() method for them with a shallow comparison for props and state.

    PureComponent is exactly the same as Component except that it handles the shouldComponentUpdate method for you. When props or state changes, PureComponent will do a shallow comparison on both props and state. Component on the other hand won’t compare current props and state to next out of the box. Thus, the component will re-render by default whenever shouldComponentUpdate is called.

    The major difference between React.PureComponent and React.Component is PureComponent does a shallow comparison on state change. It means that when comparing scalar values it compares their values, but when comparing objects it compares only references. It helps to improve the performance of the app.

    You should go for React.PureComponent when you can satisfy any of the below conditions:
        State/Props should be an immutable object
        State/Props should not have a hierarchy
        You should call forceUpdate when data changes

Controlled and Uncontrolled components?
    This relates to stateful DOM components (form elements) and the difference:
    A Controlled Component is one that takes its current value through props and notifies changes through callbacks like onChange. A parent component “controls” it by handling the callback and managing its own state and passing the new values as props to the controlled component.
    A Uncontrolled Component is one that stores its own state internally, and you query the DOM using a ref to find its current value when you need it. This is a bit more like traditional HTML.

    ./functional-components
    ./stateful-components

Hooks?
    Hooks are a new addition in React 16.8. They let you use state, lifecycle methods and other React features without writing a class.
    Hooks allow you to reuse stateful logic without changing your component hierarchy. Hooks let you split one component into smaller functions based on what pieces are related (such as setting up a subscription or fetching data).

    useState: Returns a stateful value, and a function to update it.
    During the initial render, the returned state (state) is the same as the value passed as the first argument (initialState).
    The initialState argument is the state used during the initial render. 
    If you pass an empty array as a second parameter it behaves as a componentDidMount.
    The values inside of the array are treated like a subsciption to the them.
    You can return a function on useEffect this will act as a componentWillUnmount.

    useEffect: The function passed to useEffect will run after the render is committed to the screen. By default, effects run after every completed render, but you can choose to fire it only when certain values have changed.
    The default behavior for effects is to fire the effect after every completed render behaves as a componentDidUpdate. 

    Only Run Once, on Mount: You can pass the special value of empty array [] as a way of saying “only run on mount, and clean up on unmount”.

    Run useEffect on State Change: By default, useEffect runs after every render, but it’s also perfect for running some code in response to a state change. You can limit when the effect runs by passing the second argument to useEffect. If you want your effects to run less often, you can provide a second argument – an array of values. Think of them as the dependencies for that effect. If one of the dependencies has changed since the last time, the effect will run again. (It will also still run after the initial render).

    useEffect() is for side-effects:
        A functional React component uses props and/or state to calculate the output. If the functional component makes calculations that don’t target the output value, then these calculations are named side-effects.
        Examples of side-effects are fetch requests, manipulating DOM directly, using timer functions like setTimeout(), and more.
        The component rendering and side-effect logic are independent. So it would be a mistake to perform side-effects directly in the body of the component.
        How often the component renders isn’t something you can control — if React wants to render the component, you cannot stop it.

    useRef: useRef returns a mutable ref object whose .current property is initialized to the passed argument (initialValue). The returned object will persist for the full lifetime of the component.

    useMemo: Returns a memoized value. Pass a “create” function and an array of dependencies. useMemo will only recompute the memoized value when one of the dependencies has changed. This optimization helps to avoid expensive calculations on every render.
    Remember that the function passed to useMemo runs during rendering. Don’t do anything there that you wouldn’t normally do while rendering. For example, side effects belong in useEffect, not useMemo.

    useCallback: Returns a memoized callback. Pass an inline callback and an array of dependencies. useCallback will return a memoized version of the callback that only changes if one of the dependencies has changed. This is useful when passing callbacks to optimized child components that rely on reference equality to prevent unnecessary renders (e.g. shouldComponentUpdate).

    useContext: Accepts a context object (the value returned from React.createContext) and returns the current context value for that context. The current context value is determined by the value prop of the nearest <MyContext.Provider> above the calling component in the tree.
    When the nearest <MyContext.Provider> above the component updates, this Hook will trigger a rerender with the latest context value passed to that MyContext provider.
    Don’t forget that the argument to useContext must be the context object itself:
    A component calling useContext will always re-render when the context value changes. If re-rendering the component is expensive, you can optimize it by using memoization.

    useReducer: An alternative to useState. Accepts a reducer of type (state, action) => newState, and returns the current state paired with a dispatch method. (If you’re familiar with Redux, you already know how this works.)
    useReducer is usually preferable to useState when you have complex state logic that involves multiple sub-values or when the next state depends on the previous one. useReducer also lets you optimize performance for components that trigger deep updates because you can pass dispatch down instead of callbacks.

    useLayoutEffect: The signature is identical to useEffect, but it fires synchronously after all DOM mutations. Use this to read layout from the DOM and synchronously re-render. Updates scheduled inside useLayoutEffect will be flushed synchronously, before the browser has a chance to paint.

    ./example-hooks

lifting the state?
    To shared a state between two components, the most common operation is to move it up to their closest common ancestor. This is called “lifting state up”. (ie removing the local state from the descendant component and move it into its ancestor instead.)
    Shared State: When we update an input, an other component should reflect the change (and vice versa).
    Consists of passing a function as a prop form the parent component to the child and the child exposes it's state to the parent using that function.

Higher Order Components(HOC)?
    Higher Order Component is an advanced way of reusing the component logic. Basically, it’s a pattern that is derived from React’s compositional nature. HOC are custom components which wrap another component within it. They can accept any dynamically provided child component but they won’t modify or copy any behavior from their input components. You can say that HOC are ‘pure’ components. Wrapper that adds functionalities to a component. 

    A HOC is structured like a higher-order function:
        It is a component.
        It takes another component as an argument.
        Then, it returns a new component.
        The component it returns can render the original component that was passed to it.

    Concretely, a higher-order component is a function that takes a component and returns a new component.

    ./example-hoc

keys in React?
    Keys are used for identifying unique Virtual DOM Elements with their corresponding data driving the UI. They help React to optimize the rendering by recycling all the existing elements in the DOM. These keys must be a unique number or string, using which React just reorders the elements instead of re-rendering them. This leads to increase in application’s performance.

    <div>
        { joshs.map((person, index) => ( <span key={index}>{person.name}</span>)) }
    </div>

Styles on React?
    CSS Stylesheet: Simply import css file import './DottedBox.css' so you can have a separate css file for each component.

    Inline styling: In React, inline styles are not specified as a string. Instead they are specified with an object whose key is the camelCased version of the style name, and whose value is the style’s value, usually a string.

    CSS Modules: A CSS Module is a CSS file in which all class names and animation names are scoped locally by default.

    Styled-components: is a library for React and React Native that allows you to use component-level styles in your application that are written with a mixture of JavaScript and CSS.

    ./example-styles

refs in React?
    Refs is the short hand for References in React. It allows you to get direct access to a DOM element or an instance of a component.
    References are created using React.createRef()and adding them to React elements through the attribute ref. References are commonly assigned to an instance property when a component is built, so they can be referenced by the component.

    Following are the cases when refs should be used:
        When you need to manage focus, select text or media playback
        To trigger imperative animations
        Integrate with third-party DOM libraries.

Events in React?
    In order to solve cross browser compatibility issues, your event handlers in React will be passed instances of SyntheticEvent, which is React’s cross-browser wrapper around the browser’s native event. These synthetic events have the same interface as native events you’re used to, except they work identically across all browsers.
    There are some syntactic differences:
    React events are named using camelCase, rather than lowercase.
    With JSX you pass a function as the event handler, rather than a string.

    onKeyDown, onKeyPress, onKeyUp, onBlur, onFocus, onChange, onSubmit, onClick, onDoubleClick, onMouseLeave, onMouseMove, onMouseOut, onMouseOver, 

    forms: onChange onInput onInvalid onReset onSubmit
    generic: onError onLoad onSelect onScroll onToggle onFocus onBlur
    mouse: onClick onContextMenu onDoubleClick onDrag onDragEnd onDragEnter onDragExit onDragLeave onDragOver onDragStart onDrop onMouseDown onMouseEnter onMouseLeave onMouseMove onMouseOut onMouseOver onMouseUp
    keyboard: onKeyDown onKeyPress onKeyUp
    clipboard: onCopy onCut onPaste
    touch: onTouchCancel onTouchEnd onTouchMove onTouchStart
    media: onAbort onCanPlay onCanPlayThrough onDurationChange onEmptied onEncrypted onEnded onError onLoadedData onLoadedMetadata onLoadStart onPause onPlay onPlaying onProgress onRateChange onSeeked onSeeking onStalled onSuspend onTimeUpdate onVolumeChange onWaiting
    image: onLoad onError
    animation: onAnimationStart onAnimationEnd onAnimationIteration onTransitionEnd

    ./example-synthetic-events

forms in React?
    React forms are constructed with controlled inputs. The controlled inputs aare those that their values are attached to the state of the component. 
    The way to handle forms is creating a form element to wrap the inputs, handle the form sumition with a function, then handle the inputs making their values equals to a property in the components state and adding the name attribute to the input as the property's names, to handle this it is used the onChange with a handler function attached to it, the handler function receieves the element and set the state using the new value. 

    <form onSubmit={this.handleSubmit}>
        <input type="text" name="title" onChange={this.handleChange} value={this.state.title}/>
        <button>Submit</button>
    </form>

    handleChange = (e) => {
        this.setState(()=>{
            return {[e.target.name]: e.target.value};
        });
    }

Routing in React?
    React Router is a powerful routing library built on top of React, which helps in adding new screens and flows to the application. This keeps the URL in sync with data that’s being displayed on the web page. It maintains a standardized structure and behavior and is used for developing single page web applications.

    React Routing: Only single HTML page is involved, Only the History attribute is changed, User is duped thinking he is navigating across different pages.

    Conventional Routing: Each view corresponds to a new file, A HTTP request is sent to a server and corresponding HTML page is received, User actually navigates across different pages for each view.

    Routers: At the core of every React Router application should be a router component. For web projects, react-router-dom provides <BrowserRouter> and <HashRouter> routers. The main difference between the two is the way they store the URL and communicate with your web server.

        <BrowserRouter>: uses regular URL paths. These are generally the best-looking URLs, but they require your server to be configured correctly. Specifically, your web server needs to serve the same page at all URLs that are managed client-side by React Router. Create React App supports this out of the box in development, and comes with instructions on how to configure your production server as well.

        <HashRouter>: stores the current location in the hash portion of the URL, so the URL looks something like http://example.com/#/your/page. Since the hash is never sent to the server, this means that no special server configuration is needed.

    Route Matchers: There are two route matching components: Switch and Route. When a <Switch> is rendered, it searches through its children <Route> elements to find one whose path matches the current URL. When it finds one, it renders that <Route> and ignores all others. This means that you should put <Route>s with more specific (typically longer) paths before less-specific ones.

        <Route>: The Route component most basic responsibility is to render some UI when a location matches the route’s path. A React component to render only when the location matches. It will be rendered with route props. When you use component (instead of render or children, below) the router uses React.createElement to create a new React element from the given component. That means if you provide an inline function to the component prop, you would create a new component every render. This results in the existing component unmounting and the new component mounting instead of just updating the existing component. When using an inline function for inline rendering, use the render or the children prop. This allows for convenient inline rendering and wrapping without the undesired remounting explained above.

        <Switch>: Although a <div> is used to encapsulate multiple routes inside the Router. The ‘switch’ keyword is used when you want to display only a single route to be rendered amongst the several defined routes. The <switch> tag when in use matches the typed URL with the defined routes in sequential order. When the first match is found, it renders the specified route. Thereby bypassing the remaining routes. Renders the first child <Route> or <Redirect> that matches the location.

    <Link>:Provides declarative, accessible navigation around your application.

    <NavLink>: A special version of the <Link> that will add styling attributes to the rendered element when it matches the current URL. activeClassName: The class to give the element when it is active. The default given class is active. This will be joined with the className prop. to: A string representation of the location to link to, created by concatenating the location's pathname, search, and hash properties.

    <Redirect>: Rendering a <Redirect> will navigate to a new location. The new location will override the current location in the history stack, like server-side redirects (HTTP 3xx) do. <Redirect to="/" /> | <div>Content</div>.

    withRouter(): You can get access to the history object’s properties and the closest <Route>'s match via the withRouter higher-order component. withRouter will pass updated match, location, and history props to the wrapped component whenever it renders.

    match: A match object contains information about how a <Route path> matched the URL. match objects contain the following properties:
        params - (object) Key/value pairs parsed from the URL corresponding to the dynamic segments of the path
        isExact - (boolean) true if the entire URL was matched (no trailing characters)
        path - (string) The path pattern used to match. Useful for building nested <Route>s
        url - (string) The matched portion of the URL. Useful for building nested <Link>s

    location: Locations represent where the app is now, where you want it to go, or even where it was. location returns an object with the following properties: 
        pathname: The pathname portion of the URL, without query string
        search: The query string portion of the URL, including the ?
        state: An object of data tied to this location
        action: One of PUSH, REPLACE, or POP
        key: A unique identifier for this location

    history :The term “history” and "history object" in this documentation refers to the history package, which is one of only 2 major dependencies of React Router (besides React itself), and which provides several different implementations for managing session history in JavaScript in various environments.The following terms are also used:
        “browser history” - A DOM-specific implementation, useful in web browsers that support the HTML5 history API
        “hash history” - A DOM-specific implementation for legacy web browsers
        “memory history” - An in-memory history implementation, useful in testing and non-DOM environments like React Native

    history is mutable: The history object is mutable. Therefore it is recommended to access the location from the render props of <Route>, not from history.location.

    history objects typically have the following properties and methods:
        length - (number) The number of entries in the history stack
        action - (string) The current action (PUSH, REPLACE, or POP)
        location - (object) The current location. May have the following properties:
        pathname - (string) The path of the URL
        search - (string) The URL query string
        hash - (string) The URL hash fragment
        state - (object) location-specific state that was provided to e.g. push(path, state) when this location was pushed onto the stack. Only available in browser and memory history.
        push(path, [state]) - (function) Pushes a new entry onto the history stack
        replace(path, [state]) - (function) Replaces the current entry on the history stack
        go(n) - (function) Moves the pointer in the history stack by n entries
        goBack() - (function) Equivalent to go(-1)
        goForward() - (function) Equivalent to go(1)
        block(prompt) - (function) Prevents navigation (see the history docs)

    URL Params: are placeholders in the URL that begin with a colon, like `:id`. A similar convention is used for matching dynamic segments in other popular web frameworks like Rails and Express. As with regular parameters, declaring an optional parameter is just a matter of the path property of a Route; any parameter that ends with a question mark will be treated as optional.
    Any word after the question mark (?) in a URL is considered to be a parameter which can hold values. The value for the corresponding parameter is given after the symbol "equals" (=). Multiple parameters can be passed through the URL by separating them with multiple "&".

    Query parameters are optional key-value pairs that appear to the right of the ? in a URL. Query params allow for additional application state to be serialized into the URL that can't otherwise fit into the path of the URL (i.e. everything to the left of the ?). Common use cases for query params include representing the current page number in a paginated collection, filter criteria, or sorting criteria. In web development, query parameters are used within a URL as described above but can also be used in API requests that retrieve data.

    <Router component={myComponent}/> and <Router render={myComponent}/>:
    When you use component (instead of render or children, below) the router uses React.createElement to create a new React element from the given component. That means if you provide an inline function to the componentprop, you would create a new component every render. This results in the existing component unmounting and the new component mounting instead of just updating the existing component. When using an inline function for inline rendering, use the render.

    Component mount a new component an unmount, it uses the lifecycle methods, Render just render updates the component dont called lifecycle methods.

    Routing Hooks: React Router ships with a few hooks that let you access the state of the router and perform navigation from inside your components.

        useHistory: The useHistory hook gives you access to the history instance that you may use to navigate. 
        let history = useHistory();

        useLocation: The useLocation hook returns the location object that represents the current URL. You can think about it like a useState that returns a new location whenever the URL changes.
        let location = useLocation();

        useParams: useParams returns an object of key/value pairs of URL parameters. Use it to access match.params of the current <Route>.
        let params = useParams();

        useRouteMatch: The useRouteMatch hook attempts to match the current URL in the same way that a <Route> would. It’s mostly useful for getting access to the match data without actually rendering a <Route>.
        let match = useRouteMatch("/song/:id");

    ./example-routing

Context API?
    Context provides a way to pass data through the component tree without having to pass props down manually at every level.
    In a typical React application, data is passed top-down (parent to child) via props, but this can be cumbersome for certain types of props (e.g. locale preference, UI theme) that are required by many components within an application. Context provides a way to share values like these between components without having to explicitly pass a prop through every level of the tree.
    Context is primarily used when some data needs to be accessible by many components at different nesting levels. Apply it sparingly because it makes component reuse more difficult.

    React.createContext -> const MyContext = React.createContext(defaultValue);
    Context.Provider -> <MyContext.Provider value={/* some value */}>
    Context.Consumer -> <MyContext.Consumer>
    {value => /* render something based on the context value */}
        </MyContext.Consumer>

    const MyContext = React.createContext(defaultValue);
    Creates a Context object. When React renders a component that subscribes to this Context object it will read the current context value from the closest matching Provider above it in the tree.
    The defaultValue argument is only used when a component does not have a matching Provider above it in the tree. This can be helpful for testing components in isolation without wrapping them. Note: passing undefined as a Provider value does not cause consuming components to use defaultValue.

    <MyContext.Provider value={/* some value */}>
    Every Context object comes with a Provider React component that allows consuming components to subscribe to context changes.
    Accepts a value prop to be passed to consuming components that are descendants of this Provider. One Provider can be connected to many consumers. Providers can be nested to override values deeper within the tree.
    All consumers that are descendants of a Provider will re-render whenever the Provider’s value prop changes. The propagation from Provider to its descendant consumers is not subject to the shouldComponentUpdate method, so the consumer is updated even when an ancestor component bails out of the update

    <MyContext.Consumer>
    {value => /* render something based on the context value */}
    </MyContext.Consumer>
    A React component that subscribes to context changes. This lets you subscribe to a context within a function component.
    Requires a function as a child. The function receives the current context value and returns a React node. The value argument passed to the function will be equal to the value prop of the closest Provider for this context above in the tree. If there is no Provider for this context above, the value argument will be equal to the defaultValue that was passed to createContext().

    The contextType property on a class can be assigned a Context object created by React.createContext(). This lets you consume the nearest current value of that Context type using this.context. You can reference this in any of the lifecycle methods including the render function.

    ./example-context

Flux?
    Flux is an architectural pattern which enforces the unidirectional data flow. It controls data and enables comunication between multiple components using a central store.

    Action -> Dispatcher -> Store -> View -> Dispatcher

    Flux use multiple stores.
    Mutable state.

    Dispatcher is a registry of callbacks each store registers a callback with the dispatcher. When new data comes into the dispatcher, it then uses these callbacks to propagate that data to all of the stores.

Redux?
    Its a state managment library for javascript applications.
    Single Source of Truth: The state of the entire application is store in a javascript object.
    State immutable: The only way to change the state its to create a new one using the reducers after an action was triggered.

    The elements that compose redux are:
    Actions: Actions are payloads of information that send data from our application to our store. They are the only source of information for the store. We send them to the store using store.dispatch().
    Reducers: Reducers are functions that specify how the application’s state changes in response to actions sent to the store.
    Store: javascript object that maintains the application state.
    View: Elements that displays on the UI the information provided by the store.

    Advantages: Maintainability, Organization, Performance, Predictability and Easy to Test.

    'react-redux': is designed to work with React's component model. It provides the <Provider /> HOC and the connect function.
    <Provider/> makes the redux store avaiable to any nested component that has been wrapped by the connect function. 
    The connect is a function that connects a react component to the store by receiving as parameters the functions mapStateToProps and mapDispatchToProps.
    mapStateToProps subscribes the component to the redux store, this means that every time the store is updated the function will be invoked and will provide the redux store as properties in the component. It returns an object where you assign a key as the property on your component and the value as the value to pass from the state.
    mapDispatchToProps.
    mapDispatchToProps is a function that returns a javascript object that dispatch actions to the store and makes avaibale the actions as properties on the component it returns an object with the key as the property on the component and the value as the dispatcher.
    connect(mapStateToProps, mapDispatchToProps) or could be connect(null,null). Connect returns a function that HOC wrapper.

    'redux' is a library for state managment.
    It provides the createStore, applyMiddleware and combineReducers functions.
    createStore: Creates a redux store that holds the state of the application. It receives two parameters reducers and middlewares
    createStore(reducers, middleware).
    applyMiddleware: Is a way to extend redux functionality by applying external libraries. The most common use is to support asynchronous actions. applyMiddleware(middleware).
    combienReducers is a helper function that turns an object whose values are different reducing functions into a single function. Receives an object as an argument. combineReducers({users: usersReducer, admins: adminsReducer});

    'redux-thunk' is a middleware library to hanlde the asynchronous actions on redux. edux Thunk is middleware that allows you to return functions, rather than just actions, within Redux. This allows for delayed actions, including working with promises.

    'redux-form' its a library that provides of a collection of reducer creators and actions creators that makes implementing complex and custom forms with react and redux simple and performance.
    https://redux-form.com/8.2.2/docs/api/props.md/

    redux-form primarily consists of three things:
        A Redux reducer that listens to dispatched redux-form actions to maintain your form state in Redux.
        A React component decorator that wraps your entire form in a Higher Order Component (HOC) and provides functionality via props.
        A Field component to connect your individual field inputs to the Redux store.

    reduxForm is High Order Component function that takes a configuration object and returns a new function. Is used to wrap the form component and bind user interaction to dispatch redux actions. Receives a unique name for the form.
    const userForm = reduxForm({
        form: 'userForm'
    });
    export default userForm;

    <Field /> is a component that lives inside the form wrapped component. It is used to connect the input components to the redux-form logic.
    The elements requires a name prop and a component prop. It may be a string input or a component. All props will be passed along the element generated by the component prop.
    <Field name="title" component="input" type="text"/>

    ./example-redux
    ./example-redux-thunk

Redux-Selectors?
    A selector is a function that accepts Redux state as an argument and returns data that is derived from that state. Selectors can provide performance optimizations to your application and can also help you encapsulate your global state tree. If your application is growing large and unwieldy, you may benefit from creating your own selectors or using a library such as Reselect, which utilizes memoized selectors.
    Selectors can compute derived data, allowing Redux to store the minimal possible state.

    Why should you use a selector? It is a best practice to keep your Redux store state minimal and derive data from the state as needed. Selectors help with that. They can compute derived data, allowing Redux to store the minimal possible state. Selectors are also very efficient. A selector is not recomputed unless one of its arguments changes.

    Selectors are simply functions that are used to select a subset data from a larger data collection.
    A “selector” is simply a function that accepts Redux state as an argument and returns data that is derived from that state.

    Selectors are efficient. A selector is not recomputed unless one of its arguments changes.
    Selectors are composable. They can be used as input to other selectors.

    It is a best practice to keep your Redux store state minimal and derive data from the state as needed. Selectors help with that. They can compute derived data, allowing Redux to store the minimal possible state. Selectors are also very efficient. A selector is not recomputed unless one of its arguments changes.

    createSelector(...inputSelectors | [inputSelectors], resultFunc)

    Reselect is a popular library that provides a convenient way of getting values from a store in a React-Redux application. What makes it so good is its memoization ability. You can read all this in the documentation. In two words, when you use the createSelector() function, it memiozes an output of every input selector and recalculates the resulting value only if any of the input selectors changes its output. The important thing to note here is that reselect uses reference equality (===) to determine a value change.

     for performance as Reselect provides a wrapper for creating selectors that are memoized.
     The biggest benefit of Reselect is that selectors created with the library are memoized and therefore will only re-run if their arguments change.

    import {createSelector} from 'reselect';
    const postSelector = (state) => state.posts;
    const selectedPostSelector = (state) => selectedPostIds;
    const getPosts = (post, selectedPostIds) => {
        const SelectedPosts = post.filter(item=>selectedPostIds.includes(item.id));
        return SelectedPosts;
    }
    export default createSelector(
        postSelector,
        selectedPostSelector,
        getPosts
    )
    //last argument is the function that manages the logic

Context vs Redux?
    Context API: Resourceful and ideal for small applications where state changes are minimal
    Redux: Perfect for larger applications where there are high-frequency state updates

    for low-frequency updates like locale, theme changes, user authentication, etc. the React Context is perfectly fine. But with a more complex state which has high-frequency updates, the React Context won't be a good solution. Because, the React Context will trigger a re-render on each update, and optimizing it manually can be really tough. And there, a solution like Redux is much easier to implement.

    For low-frequency updates like locale, theme changes, user authentication, etc. the React Context is perfectly fine. But with a more complex state which has high-frequency updates, the React Context won't be a good solution. Because, the React Context will trigger a re-render on each update, and optimizing it manually can be really tough. And there, a solution like Redux is much easier to implement.

Saga?
    Redux-saga is a redux middleware library, that is designed to make handling side effects in your redux app nice and simple. It achieves this by leveraging an ES6 feature called Generators, allowing us to write asynchronous code that looks synchronous, and is very easy to test. redux-saga is a library that aims to make application side effects (i.e. asynchronous things like data fetching and impure things like accessing the browser cache) easier to manage, more efficient to execute, easy to test, and better at handling failures.

    The mental model is that a saga is like a separate thread in your application that's solely responsible for side effects. redux-saga is a redux middleware, which means this thread can be started, paused and cancelled from the main application with normal redux actions, it has access to the full redux application state and it can dispatch redux actions as well.

    Contrary to redux thunk, you don’t end up in callback hell, you can test your asynchronous flows easily and your actions stay pure.

    fork(fn, ...args)
    Creates an Effect description that instructs the middleware to perform a non-blocking call on.
    fnfunction* rootSaga() {
        yield fork(schema);
        yield fork(user);
        yield fork(report);
        yield fork(actionStatistics); 
    }

    call (fn, args) runs function pause saga on promise, creates an effect that instructs the middleware to call the function fn with args.

    put(action)
    Creates an Effect description that instructs the middleware to dispatch an action to the Store. This effect is non-blocking and any errors that are thrown downstream (e.g. in a reducer) will not bubble back into the saga.

    takeLatest(action, function* saga)
    Spawns a saga on each action dispatched to the Store that matches pattern. And automatically cancels any previous saga task started previously if it's still running.
    Each time an action is dispatched to the store. And if this action matches pattern, takeLatest starts a new saga task in the background. If a saga task was started previously (on the last action dispatched before the actual action),and if this task is still running, the task will be cancelled.

    takeEvery(action, function* saga)
    Spawns a saga on each action dispatched to the Store that matches pattern action.

    all([effects])
    creates an effect description that instructs the middleware to run multiple effects in parallel and wait for all of the to complete.

    Advantages:
      syncrhonous looking code with an easy to follow step by step process.
      can allow fairly complicated flows
      easy to write test with little to no mocking
      sagas are composable
      isolates side effect code to a single area of the application
      many helper functions and solid documentation  

    ./example-redux-saga

Testing?
    It is a set o procedures to ensure the Quality of the product. Quality product delivered to the customers helps in gaining their confidence. Testing is necessary in order to provide  high quality product or software application which requires lower maintenance cost and hence results into more accurate, consistent and reliable results. Testing is required for an effective performance of software application or product. It’s important to ensure that the application should not result into any failures because it can be very expensive in the future or in the later stages of the development.

    suite (describe): is a collection of test cases that are intended to be used to test a software program to show that it has some specified set of behaviours. Test suite is a container that has a set of tests which helps testers in executing and reporting the test execution status.

    test (it||test): actual test function that invokes the function to test and uses assertion methods. A test asserttion is an expression which encapsulates some testable logic specified about a target under test.

    spy: (Supervise Function Calls, Arguments and Returned values)
    A test spy is an object that records its interaction with other objects throughout the code base. When deciding if a test was successful based on the state of available objects alone is not sufficient, we can use test spies and make assertions on things such as the number of calls, arguments passed to specific functions, return values and more. Test spies are useful to test both callbacks and how certain functions/methods are used throughout the system under test. 

    Mock: (Dummy Simulate Behavior )
    An object under test may have dependencies on other (complex) objects. To isolate the behavior of the object you want to replace the other objects by mocks that simulate the behavior of the real objects. This is useful if the real objects are impractical to incorporate into the unit test.
    A mock is like a stub but the test will also verify that the object under test calls the mock as expected. Part of the test is verifying that the mock was used correctly.
    In short, mocking is creating objects that simulate the behavior of real objects.
    Mocks are objects that register calls they receive.
    In test assertion we can verify on Mocks that all expected actions were performed. When most people talk about Mocks what they are actually referring to are Test Doubles. A Test Double is simply another object that conforms to the interface of the required Collaborator, and can be passed in its place. There are very few classes that operate entirely in isolation. Usually they need other classes or objects in order to function, whether injected via the constructor or passed in as method parameters. These are known as Collaborators or Depencies.

    Snapshot: (Photo Screen of a state on your UI)
    Snapshot tests are a very useful tool whenever you want to make sure your UI does not change unexpectedly.

    Stub: (Dummy Predefined Data)
    Stub is an object that holds predefined data and uses it to answer calls during tests. It is used when we cannot or don’t want to involve objects that would answer with real data or have undesirable side effects.
    To avoid some inconvenient interface - for instance to avoid making actual requests to a server from tests.
    To feed the system with known data, forcing a specific code path.

    Fakes: are objects that have working implementations, but not same as production one. Usually they take some shortcut and have simplified version of production code. The simplest way to think of a Fake is as a step up from a Stub. This means not only does it return values, but it also works just as a real Collaborator would.

    Types of Testing:

        Unit Testing: When you test your codebase, you take a piece of code — typically a function — and verify it behaves correctly in a specific situation. Unit testing is a structured and automated way of doing this. As a result, the more tests you write, the bigger the benefit you receive. You will also have a greater level of confidence in your codebase as you continue to develop it.

        UI Testing: User interface or UI testing, also known as GUI testing, is the process of testing the visual elements of an application to validate whether they accurately meet the expected performance and functionality. By testing the GUI, testers can validate that UI functions are free from defects. It involves testing all visual indicators and graphical icons, including menus, radio buttons, text boxes, checkboxes, toolbars, colors, fonts, and more. How your application handles user actions performed via mouse, keyboard, and other input devices. Whether the visual elements (buttons, links, text fields, images, and so on) are displayed correctly and work as intended. We can say that GUI testing is a subset of UI testing. the term UI applies to all existing types of user interfaces. A GUI, on the other hand, it’s a specific type of user interface that makes use of graphical elements with which the user can interact.
        The main aspects checked in UI testing include:
            Visual Design
            Functionality
            Usability
            Performance
            Compliance  

        Integration Testing: Integration testing is a level of software testing where individual units are combined and tested as a group. The purpose of this level of testing is to expose faults in the interaction between integrated units. Test drivers and test stubs are used to assist in Integration Testing.

        Functional Testing: Functional testing is a type of software testing whereby the system is tested against the functional requirements/specifications. Functions (or features) are tested by feeding them input and examining the output. Functional testing ensures that the requirements are properly satisfied by the application. This type of testing is not concerned with how processing occurs, but rather, with the results of processing. It simulates actual system usage but does not make any system structure assumptions.

        TDD Testing: TDD is a software development technique that involves writing automated test cases prior to writing functional pieces of the code. 
            A developer, based on requirement documents, writes an automated test case.
            The development team runs these automated test scripts against what is currently developed and the tests fail, as they should since none of the features have been implemented yet.
            development team functional code to ensure the automated test script gives them a green light.
            The development team can then refactor and organize the code to produce a tested deliverable at the end of the sprint.

        BDD Testing: BDD is a software development technique that defines the user behavior prior to writing test automation scripts or the functional pieces of code. Used in an agile sprint, this method ensures that a shippable product is generated at the end of a sprint. This involves:
            Behavior of the user is defined by a product owner/business analyst/QA in simple English.
            These are then converted to automated scripts to run against functional code.
            The development team then starts writing the functional code to ensure the automated test script gives them a green light.
            The development team can then refactor and organize the code to produce a tested deliverable at the end of the sprint.

        A/B Testing: A / B testing consists of comparing two versions of the same web page or application to check which of the two versions is more efficient. These variations, called A and B, are shown randomly to the different users of the web page. A part of them will see version A and the remaining part will see version B. This method consists of developing two versions of the same element that we are going to launch (for example, a blue CTA button and a yellow one), and then using the metrics of each variation to evaluate which one works better. Basically is a technique of comparing the effectiveness of different elements .

React Testing JEST?
    Jest: Jest is a library for testing JavaScript code is a Test runner. It's an open source project maintained by Facebook, and it's especially well suited for React code testing, although not limited to that: it can test any JavaScript code. the biggest feature of Jest is it’s an out of the box solution that works without having to interact with other testing libraries to perform its job.

    describe(name, fn): creates a block that groups together several related tests. Jest method for containing one or more related tests. Every time you start writing a new suite of tests for a functionality wrap it in a describe block. As you can see it takes two arguments: a string for describing the test suite, and a callback function for wrapping the actual test. 

    test(name, fn, timeout): Also under the alias: it(name, fn, timeout). All you need in a test file is the test method which runs a test. A function called test which is the actual test block. In the test block you have to define the expected result. 

    expect: When you're writing tests, you often need to check that values meet certain conditions. expect gives you access to a number of "matchers" that let you validate different things.
    expect(value): The expect function is used every time you want to test a value. You will rarely call expect by itself. Instead, you will use expect along with a "matcher" function to assert something about a value. Jest matchers:

        toBe(value): Use .toBe to compare primitive values or to check referential identity of object instances. It calls Object.is to compare values, which is even better for testing than === strict equality operator.

        not: If you know how to test something, .not lets you test its opposite.

        toBeTruthy(): Use .toBeTruthy when you don't care what a value is and you want to ensure a value is true in a boolean context. 

        toBeFalsy(): Use .toBeFalsy when you don't care what a value is and you want to ensure a value is false in a boolean context. 

        toContain(item): Use .toContain when you want to check that an item is in an array. For testing the items in the array, this uses ===, a strict equality check. .toContain can also check whether a string is a substring of another string.

        toEqual(value): Use .toEqual to compare recursively all properties of object instances (also known as "deep" equality). It calls Object.is to compare primitive values, which is even better for testing than === strict equality operator.

        toMatch(regexp | string): Use .toMatch to check that a string matches a regular expression.

        resolves: Use resolves to unwrap the value of a fulfilled promise so any other matcher can be chained. If the promise is rejected the assertion fails.

        rejects: Use .rejects to unwrap the reason of a rejected promise so any other matcher can be chained. If the promise is fulfilled the assertion fails.

        assertions(number): verifies that a certain number of assertions are called during a test. This is often useful when testing asynchronous code, in order to make sure that assertions in a callback actually got called.

        hasAssertions() verifies that at least one assertion is called during a test. This is often useful when testing asynchronous code, in order to make sure that assertions in a callback actually got called.

        toHaveReturned(): Also under the alias: .toReturn(). If you have a mock function, you can use .toHaveReturned to test that the mock function successfully returned (i.e., did not throw an error) at least one time.

        toHaveReturnedTimes(number): Also under the alias: .toReturnTimes(number). Use .toHaveReturnedTimes to ensure that a mock function returned successfully (i.e., did not throw an error) an exact number of times. Any calls to the mock function that throw an error are not counted toward the number of times the function returned.

        toThrow(error?): Also under the alias: .toThrowError(error?)

    Mock Functions: Mock functions are also known as "spies", because they let you spy on the behavior of a function that is called indirectly by some other code, rather than only testing the output. You can create a mock function with jest.fn(). If no implementation is given, the mock function will return undefined when invoked.    

    Snapshot Testing: Snapshot tests are a very useful tool whenever you want to make sure your UI does not change unexpectedly. A typical snapshot test case renders a UI component, takes a snapshot, then compares it to a reference snapshot file stored alongside the test. The test will fail if the two snapshots do not match: either the change is unexpected, or the reference snapshot needs to be updated to the new version of the UI component. A similar approach can be taken when it comes to testing your React components. Instead of rendering the graphical UI, which would require building the entire app, you can use a test renderer to quickly generate a serializable value for your React tree.
        toMatchSnapshot(propertyMatchers?, hint?): This ensures that a value matches the most recent snapshot.

React Testing @testing-library?
    @testing-library: The @testing-library family of packages helps you test UI components in a user-centric way. The core library, DOM Testing Library, is a light-weight solution for testing web pages by querying and interacting with DOM nodes (whether simulated with JSDOM/Jest or in the browser). The main utilities it provides involve querying the DOM for nodes in a way that's similar to how the user finds elements on the page. In this way, the library helps ensure your tests give you confidence that your application will work when a real user uses it.

    React Testing Library: React Testing Library builds on top of DOM Testing Library by adding APIs for working with React components.
    Projects created with Create React App have out of the box support for React Testing Library. If that is not the case, you can add it via npm like so:
        npm install --save-dev @testing-library/react

    What this library is not:
        A test runner or framework
        Specific to a testing framework
        DOM Testing Library works with any environment that provides DOM APIs, such as Jest, Mocha + JSDOM, or a real browser

    Queries are the methods that Testing Library gives you to find elements on the page. There are several types of queries ("get", "find", "query"); the difference between them is whether the query will throw an error if no element is found or if it will return a Promise and retry. Depending on what page content you are selecting, different queries may be more or less appropriate. Use semantic queries to test your page in the most accessible way.

    The base queries from DOM Testing Library require you to pass a container as the first argument. Most framework-implementations of Testing Library provide a pre-bound version of these queries when you render your components with them which means you do not have to provide a container.

    screen: All of the queries exported by DOM Testing Library accept a container as the first argument. Because querying the entire document.body is very common, DOM Testing Library also exports a screen object which has every query that is pre-bound to document.body (using the within functionality). Wrappers such as React Testing Library re-export screen so you can use it the same way.
    const exampleInput = screen.getByLabelText('Example')

    render: Render into a container which is appended to document.body.
        container: By default, React Testing Library will create a div and append that div to the document.body and this is where your React component will be rendered. If you provide your own HTMLElement container via this option, it will not be appended to the document.body automatically.
        
        The render method returns an object that has a few properties:
            queries: The most important feature of render is that the queries from DOM Testing Library are automatically returned with their first argument bound to the baseElement, which defaults to document.body. 

    TextMatch: Most of the query APIs take a TextMatch as an argument, which means the argument can be either a string, regex, or a function which returns true for a match and false for a mismatch.
    screen.getByText(/^hello world$/i) // full string match, ignore case

    Types of queries:
        Single Elements:
            getBy...: Returns the matching node for a query, and throw a descriptive error if no elements match or if more than one match is found (use getAllBy instead if more than one element is expected).
            queryBy...: Returns the first matching node for a query, and return null if no elements match. This is useful for asserting an element that is not present. Throws an error if more than one match is found (use queryAllBy instead if this is OK).
            findBy...: Returns a Promise which resolves when an element is found which matches the given query. The promise is rejected if no element is found or if more than one element is found after a default timeout of 1000ms. If you need to find more than one element, use findAllBy.
        Multiple Elements:
            getAllBy...: Returns an array of all matching nodes for a query, and throws an error if no elements match.
            queryAllBy...: Returns an array of all matching nodes for a query, and return an empty array ([]) if no elements match.
            findAllBy...: Returns a promise which resolves to an array of elements when any elements are found which match the given query. The promise is rejected if no elements are found after a default timeout of 1000ms.

    ByText(): This will search for all elements that have a text node with textContent matching the given TextMatch.

    ByTestId(): A shortcut to container.querySelector(`[data-testid="${yourId}"]`) (and it also accepts a TextMatch).

    ByRole(): Queries for elements with the given role (and it also accepts a TextMatch). Default roles are taken into consideration e.g. <button /> has the button role without explicitly setting the role attribute.

    ByLabelText(): This will search for the label that matches the given TextMatch, then find the element associated with that label.

    ByDisplayValue(): Returns the input, textarea, or select element that has the matching display value.

    Based on the Guiding Principles, your test should resemble how users interact with your code (component, page, etc.) as much as possible. With this in mind, we recommend this order of priority: 
        Queries Accessible to Everyone queries that reflect the experience of visual/mouse users as well as those that use assistive technology
            getByRole: This can be used to query every element that is exposed in the accessibility tree. With the name option you can filter the returned elements by their accessible name. This should be your top preference for just about everything. There's not much you can't get with this (if you can't, it's possible your UI is inaccessible). Most often, this will be used with the name option like so: getByRole('button', {name: /submit/i}). Check the list of roles.
            getByLabelText: Only really good for form fields, but this is the number one method a user finds those elements, so it should be your top preference.
            getByPlaceholderText: A placeholder is not a substitute for a label. But if that's all you have, then it's better than alternatives.
            getByText: Not useful for forms, but this is the number 1 method a user finds most non-interactive elements (like divs and spans).
            getByDisplayValue: The current value of a form element can be useful when navigating a page with filled-in values.

        Semantic Queries HTML5 and ARIA compliant selectors. Note that the user experience of interacting with these attributes varies greatly across browsers and assistive technology.
            getByAltText: If your element is one which supports alt text (img, area, and input), then you can use this to find that element.
            getByTitle: The title attribute is not consistently read by screenreaders, and is not visible by default for sighted users

        Test IDs
            getByTestId: The user cannot see (or hear) these, so this is only recommended for cases where you can't match by role or text or it doesn't make sense (e.g. the text is dynamic).


    Firing Events: Fire DOM events. fireEvent[eventName](node: HTMLElement, eventProperties: Object). Example: fireEvent.click(HTMLElement, eventProperties) or fireEvent.change(HTMLElement, eventProperties).

        target: When an event is dispatched on an element, the event has the subjected element on a property called target. As a convenience, if you provide a target property in the eventProperties (second argument), then those properties will be assigned to the node which is receiving the event.

        dataTransfer: Drag events have a dataTransfer property that contains data transferred during the operation. As a convenience, if you provide a dataTransfer property in the eventProperties (second argument), then those properties will be added to the event.

        Keyboard events: There are three event types related to keyboard input - keyPress, keyDown, and keyUp. When firing these you need to reference an element in the DOM and the key you want to fire.

        Convenience methods for creating DOM events that can then be fired by fireEvent, allowing you to have a reference to the event created: this might be useful if you need to access event properties that cannot be initiated programmatically (such as timeStamp). You can also create generic events.

    Async Methods: Several utilities are provided for dealing with asynchronous code. These can be useful to wait for an element to appear or disappear in response to an event, user action, timeout, or Promise.findBy methods are a combination of getBy queries and waitFor. They accept the waitFor options as the last argument (e.g. await screen.findByText('text', queryOptions, waitForOptions). findBy queries work when you expect an element to appear but the change to the DOM might not happen immediately.
    waitFor: When in need to wait for any period of time you can use waitFor, to wait for your expectations to pass.

    ./example-testing

One-Way vs Two-Way databinding?
    Data Binding is the process of connecting information with displayable objects from a programmatic perspective. 

    One-Way binding:     
        When properties in the model get updated, so does the UI.
        OR
        When UI elements get updated, the changes get propagated back to the model.

        One-way data binding is a situation where information flows in only one direction, typically from a data source to the control. This has the effect of making the variable read-only from the user's perspective

    Two-way binding:
        When properties in the model get updated, so does the UI.
        AND
        When UI elements get updated, the changes get propagated back to the model.

        Two-way binding is when the information flows in both directions from data source to the control, and from the control to data source. This has the effect to be updated by the user. Anything they do with the control affect the information it displays and the information get stored.

    React is one-way databinding.
    Its possible to implement two-way databinding by using input -> ngOnchange -> setState -> input value = this.state

Server Side Rendering?
    Use
        Fast initial page load especially on slower networks
        Improved SEO across all search engines
        Initialized data at render time
        User requesting can get unique page
        Users with javascript disabled can still see the application

    Don't Use
        Initial page load not most important
        Don’t have ability to spin up and maintain servers
        Static site meets the business need
        Framework in use doesn’t support server side rendering

React Advantages:
    It increases the application’s performance
    It can be conveniently used on the client as well as server side
    Because of JSX, code’s readability increases
    React is easy to integrate with other frameworks like Meteor, Angular, etc
    Using React, writing UI test cases become extremely easy

React Limitations:
    React is just a library, not a full-blown framework
    Its library is very large and takes time to understand
    It can be little difficult for the novice programmers to understand
    Coding gets complex as it uses inline templating and JSX

React vs Angular?
    1. ARCHITECTURE	Only the View of MVC	Complete MVC
    2. RENDERING	Server-side rendering	Client-side rendering
    3. DOM	        Uses virtual DOM	    Uses real DOM
    4. DATA BINDING	One-way data binding	Two-way data binding
    5. DEBUGGING	Compile time debugging	Runtime debugging
    6. AUTHOR	    Facebook	            Google
